Map prebuildResult = [:]
String prebuildResultsFile = 'prebuildResults.yml'
String prebuildResultsStash = 'prebuildResults'

pipeline {

  agent {
    kubernetes {
      label "build-keycloak-operator-${UUID.randomUUID().toString()}".take(63) // all your pods will be named with this prefix, followed by a unique id
      yamlFile '.jenkins/k8s-build-pod.yaml'  // path to the pod definition relative to the root of our project
      defaultContainer 'build'  // define a default container if more than a few stages use it, will default to jnlp container
    }
  }

  options {
    ansiColor('xterm')

    // Preserve stashes from the 20 latest builds
    preserveStashes(buildCount: 20)

    timestamps()
  }

  stages {

    stage('prebuild') {
      steps {
        container('build') {
          script {
            // Authenticate with ECR
            ecrAuth

            // Get and persist the image tags
            prebuildResult.imageFull = sh(script: 'make display-image-string-full', returnStdout: true).toString().trim()
            prebuildResult.imageLatest = sh(script: 'make display-image-string-latest', returnStdout: true).toString().trim()
            prebuildResult.imageTag = sh(script: 'make display-image-tag', returnStdout: true).toString().trim()
            prebuildResult.debugImageFull = sh(script: 'make display-debug-image-string-full', returnStdout: true).toString().trim()
            prebuildResult.debugImageLatest = sh(script: 'make display-debug-image-string-latest', returnStdout: true).toString().trim()

            // Check to see if a docker image with this tag already exists
            prebuildResult.imageExists = dockerImageExists(prebuildResult.imageFull)
            prebuildResult.debugImageExists = dockerImageExists(prebuildResult.debugImageFull)

            // Write results to a file
            writeYaml(file: prebuildResultsFile, data: prebuildResult)

            // Stash the results
            stash includes: prebuildResultsFile, name: prebuildResultsStash
          }
        }
      } // steps
    } // stage - prebuild

    stage('build') {
      parallel {
        stage('build operator') {
          when {
            beforeAgent true
            not { expression { prebuildResult.imageExists } }
          }

          steps {
            container('build') {
              withCredentials([usernamePassword(credentialsId: 'github-token', usernameVariable: 'GUSER', passwordVariable: 'GPASS'),
                               usernamePassword(credentialsId: 'artifactory', usernameVariable: 'ARTIFACTORY_CREDENTIALS_USR', passwordVariable: 'ARTIFACTORY_CREDENTIALS_PSW')]) {
                withDockerRegistry([credentialsId: 'artifactory', url: constants.DOCKER_URL ]) {
                  retry(3) {
                    script {
                      env.ImageLatest = prebuildResult.imageLatest
                      env.ImageFull = prebuildResult.imageFull
                      env.ImageTag = prebuildResult.imageTag
                      env.artifactory_contextUrl = constants.ARTIFACTORY_INTERNAL_URL

                      sh '''
                        git config --global credential.username \${GUSER}
                        git config --global credential.helper "!echo password=\${GPASS}; echo"

                        make code/compile
                        make code/check

                        docker build --network=host --no-cache -t $ImageFull .
                        docker tag $ImageFull $ImageLatest
                      '''
                    } // end of script
                  } // end of retry
                } // end of withDockerRegistry
              } // end of withCredentials
            } // end of container
          } //end of steps
        } // stage - build
        stage('build debug image') {
          when {
            beforeAgent true
            not { expression { prebuildResult.debugImageExists } }
          }

          steps {
            container('build') {
              withCredentials([usernamePassword(credentialsId: 'github-token', usernameVariable: 'GUSER', passwordVariable: 'GPASS'),
                               usernamePassword(credentialsId: 'artifactory', usernameVariable: 'ARTIFACTORY_CREDENTIALS_USR', passwordVariable: 'ARTIFACTORY_CREDENTIALS_PSW')]) {
                withDockerRegistry([credentialsId: 'artifactory', url: constants.DOCKER_URL ]) {
                  retry(3) {
                    script {
                      env.ImageLatest = prebuildResult.debugImageLatest
                      env.ImageFull = prebuildResult.debugImageFull
                      env.artifactory_contextUrl = constants.ARTIFACTORY_INTERNAL_URL

                      sh '''
                        git config --global credential.username \${GUSER}
                        git config --global credential.helper "!echo password=\${GPASS}; echo"

                        docker build --network=host --no-cache -t $ImageFull keycloak-debug/
                        docker tag $ImageFull $ImageLatest
                      '''
                    } // end of script
                  } // end of retry
                } // end of withDockerRegistry
              } // end of withCredentials
            } // end of container
          } //end of steps
        } // stage - build debug
      } // parallel 
    } // stage - build

    stage('test') {
      when {
        beforeAgent true
        not { expression { prebuildResult.imageExists } }
      }
      steps {
        container('build') {
          script {
            sh '''
               #requires gcc to be installed
               #make test/unit
            '''
          }
        }
      } // steps
    } // stage - test

    stage('security') {
      stages { 
        stage('aqua') {
          steps {
            container('build') {
              retry(3) {
                // Run the Aqua scan
                // disable Aqua because it is currently broken or flakey
                // aquaScan(prebuildResult.imageFull)
              }
            }
          }
        } // stage - aqua
      }
    } // stage - security

    stage('publish') {
      parallel {
        stage('publish operator') {
          when {
            allOf {
              branch 'cogito-build'
              not { expression { prebuildResult.imageExists } }
            }
            beforeAgent true
          }
          steps {
            container('build') {
              script {
                withDockerRegistry([credentialsId: 'artifactory', url: constants.DOCKER_URL ]) {
                  sh "docker push ${prebuildResult.imageFull}"
                  sh "docker push ${prebuildResult.imageLatest}"
                }
              }
            }
          }
        } // stage - publish operator
        stage('publish debug') {
          when {
            allOf {
              branch 'cogito-build'
              not { expression { prebuildResult.debugImageExists } }
            }
            beforeAgent true
          }
          steps {
            container('build') {
              script {
                withDockerRegistry([credentialsId: 'artifactory', url: constants.DOCKER_URL ]) {
                  sh "docker push ${prebuildResult.debugImageFull}"
                  sh "docker push ${prebuildResult.debugImageLatest}"
                }
              }
            }
          }
        } // stage - publish debug
      } // parallel
    } // stage - publish

    stage('dev deploy') {
      agent {
        label 'master'
      }
      when {
        beforeAgent true
        branch 'master'
      }
      steps {
        milestone(ordinal: 1, label: 'deployment-dev')
        build job: 'binnacle-apps-autoupdate', parameters: [
            string(name: 'binnaclePath', value: 'aws/cogito2-saas-cogito-dev-001/us-east-1/saas'),
            string(name: 'binnacleFile', value: 'cogito-saas-keycloak-operator.yaml'),
            string(name: 'imageTag', value: prebuildResult.imageTag)
        ]
        build job: 'binnacle-aws-cogito2-saas-cogito-dev-001-us-east-1-saas-cogito-saas-keycloak-operator-poll', quietPeriod: 2
      }
    } // stage - dev deploy

    stage("confirm promote to qua") {
      when {
        branch 'master'
      }
      agent none
      steps {
        milestone(ordinal: 2, label: 'promote-qua')
        input(message: "Promote to Quality Assurance?")
      }
    } // stage - confirm promote to qua

    stage('qua deploy') {
      agent {
        label 'master'
      }
      when {
        beforeAgent true
        branch 'master'
      }
      steps {
        build job: 'binnacle-apps-autoupdate', parameters: [
            string(name: 'binnaclePath', value: 'aws/cogito2-saas-cogito-qua-001/us-east-1/saas'),
            string(name: 'binnacleFile', value: 'cogito-saas-keycloak-operator.yaml'),
            string(name: 'imageTag', value: prebuildResult.imageTag)
        ]
        build job: 'binnacle-aws-cogito2-saas-cogito-qua-001-us-east-1-saas-cogito-saas-keycloak-operator-poll', quietPeriod: 2
      }
    } // stage - qua deploy 
  } // stages
}
